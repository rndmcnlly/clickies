<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>ðŸ’¾ v86 Savestream Test Suite</title>
  <link rel="stylesheet" href="v86/album-style.css">
  <style>
    body {
      font-family: sans-serif;
      padding: 20px;
      background: #f0f0f0;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    h1 {
      color: #333;
      margin-top: 0;
    }

    .card {
      background: white;
      border-radius: 15px;
      padding: 20px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      margin-bottom: 20px;
      max-width: 1280px;
      width: 80%;
      box-sizing: border-box;
    }

    .card h3 {
      margin-top: 0;
      color: #007bff;
    }

    #testOutput {
      background: #000;
      color: rgb(255, 255, 255);
      border: 1px solid #444;
      padding: 10px;
      white-space: pre-wrap;
      height: 600px;
      overflow-y: auto;
      font-size: 0.9em;
      font-family: monospace;
      border-radius: 8px;
    }

    .test-controls {
      background: #fff;
      padding: 15px 20px;
      border-radius: 15px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      margin-bottom: 20px;
      width: 80%;
      max-width: 1280px;
      box-sizing: border-box;
    }

    .test-checkboxes {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
      gap: 8px;
      margin: 15px 0;
    }

    .test-checkbox-item {
      display: flex;
      align-items: center;
    }

    .test-checkbox-item input[type="checkbox"] {
      margin-right: 8px;
      cursor: pointer;
    }

    .test-checkbox-item label {
      cursor: pointer;
      user-select: none;
      color: #555;
    }

    .button-group {
      margin-top: 15px;
      display: flex;
      gap: 10px;
    }

    .button-group button {
      padding: 10px 20px;
      border-radius: 20px;
      border: none;
      background-color: #007bff;
      color: white;
      font-weight: bold;
      cursor: pointer;
      transition: background 0.2s, transform 0.1s;
      font-size: 14px;
    }

    .button-group button:hover:not(:disabled) {
      background-color: #0056b3;
    }

    .button-group button:active:not(:disabled) {
      transform: scale(0.98);
    }

    .button-group button.secondary {
      background-color: #95a5a6;
    }

    .button-group button.secondary:hover:not(:disabled) {
      background-color: #7f8c8d;
    }

    .file-input-wrapper {
      margin-bottom: 15px;
    }

    .file-input-label {
      display: inline-block;
      padding: 10px 20px;
      background: #007bff;
      color: white;
      border-radius: 20px;
      cursor: pointer;
      transition: background 0.2s;
      font-weight: bold;
      font-size: 14px;
    }

    .file-input-label:hover {
      background: #0056b3;
    }

    input[type="file"] {
      display: none;
    }

    .selected-file {
      margin-top: 10px;
      padding: 10px;
      background: #e8f5e9;
      border-radius: 8px;
      color: #2e7d32;
      font-size: 0.9em;
    }

    .test-section {
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid #e0e0e0;
    }

    .test-section:first-child {
      border-top: none;
      margin-top: 0;
      padding-top: 0;
    }

    .test-section-title {
      font-weight: bold;
      color: #007bff;
      margin-bottom: 8px;
    }
  </style>
</head>

<body>
  <h1>ðŸ’¾ v86 Savestream Test Suite</h1>

  <div class="section" style="width: 80%; max-width: 1280px;">
    <div style="background: white; padding: 15px 20px; border-radius: 15px; box-shadow: 0 2px 5px rgba(0,0,0,0.1);">
      <h3 style="margin-top: 0; color: #007bff;">Load Test Data</h3>
      <p style="color: #555;">Please select the folder containing your unzipped <code>.bin</code> savestates (e.g., the unzipped <code>msdos-states</code> folder).</p>
      <div class="file-input-wrapper">
        <label for="folderPicker" class="file-input-label">
          Choose Folder
        </label>
        <input type="file" id="folderPicker" webkitdirectory multiple />
      </div>
      <div id="selectedFiles" class="selected-file" style="display: none;"></div>
    </div>
  </div>

  <div class="test-controls" id="testControls" style="display: none;">
    <h3>Select Tests to Run</h3>
    
    <div class="test-section">
      <div class="test-section-title">Individual Function Tests</div>
      <div class="test-checkbox-item" style="margin-bottom: 10px; padding-bottom: 10px; border-bottom: 1px solid #e0e0e0;">
        <input type="checkbox" id="selectAllIndividual" checked />
        <label for="selectAllIndividual"><strong>Select All Individual Tests</strong></label>
      </div>
      <div class="test-checkboxes" id="individualTestCheckboxes"></div>
    </div>

    <div class="test-section">
      <div class="test-section-title">Function Pair Tests</div>
      <div class="test-checkbox-item" style="margin-bottom: 10px; padding-bottom: 10px; border-bottom: 1px solid #e0e0e0;">
        <input type="checkbox" id="selectAllPairs" checked />
        <label for="selectAllPairs"><strong>Select All Pair Tests</strong></label>
      </div>
      <div class="test-checkboxes" id="pairTestCheckboxes"></div>
    </div>

    <div class="test-section">
      <div class="test-checkbox-item" style="margin-bottom: 10px; padding-bottom: 10px; border-bottom: 1px solid #e0e0e0;">
        <input type="checkbox" id="selectAll" checked />
        <label for="selectAll"><strong>Select All Tests</strong></label>
      </div>
    </div>

    <div class="button-group">
      <button id="runSelectedTests">Run Selected Tests</button>
      <button id="clearOutput" class="secondary">Clear Output</button>
    </div>
  </div>

  <div class="section" style="width: 80%; max-width: 1280px;">
    <div style="background: white; padding: 15px 20px; border-radius: 15px; box-shadow: 0 2px 5px rgba(0,0,0,0.1);">
      <h3 style="margin-top: 0; color: #007bff;">Test Output</h3>
      <pre id="testOutput">Awaiting savestate folder to run tests...</pre>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@msgpack/msgpack@3.1.1/dist.umd/msgpack.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/fast-json-patch@3.1.1/dist/fast-json-patch.min.js"></script>
  <script src="./savestreams_updated.js"></script>

  <script>
    // --- Test Helpers ---
    const out = document.getElementById("testOutput");
    const log = (msg) => {
        out.textContent += msg + "\n";
        out.scrollTop = out.scrollHeight; 
    };
    const pass = (msg) => log(`âœ… PASS: ${msg}`);
    const fail = (msg, e) => {
        log(`âŒ FAIL: ${msg}`);
        if (e) {
            log(`      Error: ${e.message}`);
            log(`      Stack: ${e.stack ? e.stack.replace(e.message, '') : 'N/A'}`);
        }
    };
    const assert = (condition, message) => {
        if (condition) pass(message);
        else throw new Error(message);
    };
    const assertEquals = (a, b, message) => {
        if (a === b) pass(message);
        else throw new Error(`${message} (Expected: ${b}, Got: ${a})`);
    };
    const assertArraysEqual = (a, b, message) => {
        if (!a || !b) {
            throw new Error(`${message} (One of the arrays is null or undefined)`);
        }
        if (a.length !== b.length) {
            throw new Error(`${message} (length mismatch: ${a.length} vs ${b.length})`);
        }
        for (let i = 0; i < a.length; i++) {
            if (a[i] !== b[i]) {
                throw new Error(`${message} (mismatch at index ${i}: ${a[i]} vs ${b[i]})`);
            }
        }
        pass(message);
    };
    
    const runTest = async (name, testFn) => {
        log(`\n--- Testing ${name} ---`);
        const t0 = performance.now();
        let error = null;
        try {
            await testFn();
        } catch (e) {
            error = e;
        }
        const t1 = performance.now();
        const duration = ((t1 - t0) / 1000).toFixed(3);

        if (error) {
            fail(name, error);
        }
        log(`--- Finished ${name} in ${duration}s ---`);
        
        await new Promise(r => setTimeout(r, 0));
    };
    // --- End Test Helpers ---

    // Test registry and state
    let individualTests = {};
    let pairTests = {};
    let globalSavestates = null;
    let globalEncodedSavestream = null;
    let globalAPIs = null;

    // Initialize test registry
    function initializeTests(savestates) {
      globalSavestates = savestates;
      globalEncodedSavestream = null;

      const { _internal } = window.v86Savestream;
      const {
        padTo,
        splitV86Savestate,
        recombineV86Savestate,
        makeAlignedBufferBlock,
        makeUnalignedBufferBlock,
        hashBlock
      } = _internal;
      
      const { encode, decode, decodeLen, decodeOne, trim } = window.v86Savestream;
      
      const textEncoder = new TextEncoder();
      const textDecoder = new TextDecoder("utf-8");

      globalAPIs = {
        padTo, splitV86Savestate, recombineV86Savestate,
        makeAlignedBufferBlock, makeUnalignedBufferBlock, hashBlock,
        encode, decode, encodeStreaming, decodeStreaming, decodeLen, decodeOne, trim,
        textEncoder, textDecoder
      };

      // ===== INDIVIDUAL FUNCTION TESTS =====
      individualTests = {
        "padTo (Private API)": async () => {
          const { padTo, textEncoder } = globalAPIs;
          assertArraysEqual(padTo(textEncoder.encode('1234'), 4), textEncoder.encode('1234'), "pads 4 bytes to 4");
          assertArraysEqual(padTo(textEncoder.encode('123'), 4), new Uint8Array([49, 50, 51, 0]), "pads 3 bytes to 4");
          
          const padded256 = padTo(textEncoder.encode('12345'), 256);
          assertEquals(padded256.length, 256, "pads 5 bytes to 256 length");
          assertArraysEqual(padded256.subarray(0, 5), textEncoder.encode('12345'), "padded 256 buffer has correct prefix");
        },
        
        "hashBlock (Private API)": async () => {
          const { hashBlock } = globalAPIs;
          const blockA = new Uint8Array([1, 2, 3, 4, 5]);
          const blockB = new Uint8Array([1, 2, 3, 4, 5]);
          const blockC = new Uint8Array([5, 4, 3, 2, 1]);
          const hashA = hashBlock(blockA);
          const hashB = hashBlock(blockB);
          const hashC = hashBlock(blockC);

          assert(hashA === hashB, "identical blocks produce identical hashes");
          assert(hashA !== hashC, "different blocks produce different hashes");
          assert(typeof hashA === 'number', "hash returns a number");
        },

        "splitV86Savestate (Private API, Real Data)": async () => {
          const { splitV86Savestate } = globalAPIs;
          assert(globalSavestates.length > 0, "Must have at least 1 savestate");
          for (let i = 0; i < globalSavestates.length; i++) {
              const file_content = globalSavestates[i];
              const { headerBlock, infoBlock, bufferBlock } = splitV86Savestate(file_content);
              const padding = ((infoBlock.length + 3) & ~3) - infoBlock.length;
              
              assertEquals(headerBlock.length, 16, `Header block ${i} is 16 bytes`);
              assert(infoBlock.length > 0, `Info block ${i} is not empty`);
              assert(bufferBlock.length > 0, `Buffer block ${i} is not empty`);
              assertEquals(headerBlock.length + infoBlock.length + bufferBlock.length + padding, file_content.length, `Split blocks ${i} sum to original length`);
          }
        },

        "recombineV86Savestate (Private API, Real Data)": async () => {
          const { splitV86Savestate, recombineV86Savestate } = globalAPIs;
          assert(globalSavestates.length > 0, "Must have at least 1 savestate");
          for (let i = 0; i < globalSavestates.length; i++) {
              const file_content = globalSavestates[i];
              const { headerBlock, infoBlock, bufferBlock } = splitV86Savestate(file_content);
              const recombined = recombineV86Savestate(headerBlock, infoBlock, bufferBlock);
              assertArraysEqual(recombined, file_content, `Recombined file ${i} matches original`);
          }
        },

        "makeAlignedBufferBlock (Private API, Real Data)": async () => {
          const { splitV86Savestate, makeAlignedBufferBlock, textDecoder } = globalAPIs;
          const blockSize = 256;
          const superBlockSize = blockSize * 256;

          for (let i = 0; i < globalSavestates.length; i++) {
              const file_content = globalSavestates[i];
              const { headerBlock, infoBlock, bufferBlock } = splitV86Savestate(file_content);
              const infoJson = JSON.parse(textDecoder.decode(infoBlock));

              const aligned_buffer = makeAlignedBufferBlock(infoJson, bufferBlock, blockSize, superBlockSize);
              
              assertEquals(aligned_buffer.length % superBlockSize, 0, `Aligned buffer ${i} length (${aligned_buffer.length}) is multiple of superblock size (${superBlockSize})`);
              assert(aligned_buffer.length >= bufferBlock.length, `Aligned buffer ${i} is at least as large as original`);
          }
        },

        "makeUnalignedBufferBlock (Private API, Real Data)": async () => {
          const { splitV86Savestate, makeAlignedBufferBlock, makeUnalignedBufferBlock, textDecoder } = globalAPIs;
          const blockSize = 256;
          const superBlockSize = blockSize * 256;

          for (let i = 0; i < globalSavestates.length; i++) {
              const file_content = globalSavestates[i];
              const { headerBlock, infoBlock, bufferBlock } = splitV86Savestate(file_content);
              const infoJson = JSON.parse(textDecoder.decode(infoBlock));

              const aligned_buffer = makeAlignedBufferBlock(infoJson, bufferBlock, blockSize, superBlockSize);
              const unaligned_buffer = makeUnalignedBufferBlock(infoJson, aligned_buffer, blockSize);
              
              assertArraysEqual(unaligned_buffer, bufferBlock, `Unaligned buffer ${i} matches original buffer block`);
          }
        },

        "encode (Public API, Real Data)": async () => {
          const { encode } = globalAPIs;
          assert(globalSavestates.length > 0, "Must have at least 1 savestate");
          
          globalEncodedSavestream = await encode(globalSavestates, {
            onProgress: (current, total) => {
              log(`   Encoding progress: ${current}/${total} states`);
            }
          });
          
          assert(globalEncodedSavestream instanceof Uint8Array, "Encoded savestream is Uint8Array");
          assert(globalEncodedSavestream.length > 0, "Encoded savestream is not empty");
        },

        "encodeStreaming (Public API, Real Data)": async () => {
          const { encode } = globalAPIs;
          assert(globalSavestates.length > 0, "Must have at least 1 savestate");
          
          let numEncodedChunks = 0;
          for await (const chunk of await window.v86Savestream.encodeStreaming(globalSavestates)) {
            numEncodedChunks++;
            log(`   Encoded chunk ${numEncodedChunks} size: ${chunk.length} bytes`);
          }
          
          assert(numEncodedChunks == globalSavestates.length, "encodeStreaming yields correct number of chunks");
        },

        "decodeLen (Public API, Real Data)": async () => {
          const { encode, decodeLen } = globalAPIs;
          if (!globalEncodedSavestream) {
            globalEncodedSavestream = await encode(globalSavestates);
          }
          
          const length = await decodeLen(globalEncodedSavestream);
          assertEquals(length, globalSavestates.length, "decodeLen returns correct count");
        },

        "decodeOne (Public API, Real Data)": async () => {
          const { encode, decodeOne } = globalAPIs;
          if (!globalEncodedSavestream) {
            globalEncodedSavestream = await encode(globalSavestates);
          }
          
          for (let i = 0; i < globalSavestates.length; i++) {
              const decoded_one = await decodeOne(globalEncodedSavestream, i);
              assertArraysEqual(decoded_one, globalSavestates[i], `decode_one(${i}) matches original state ${i}`);
          }
        },

        "trim (Public API, Real Data)": async () => {
          const { encode, trim } = globalAPIs;
          if (globalSavestates.length < 3) {
              log("--- Skipping trim test: requires at least 3 savestates.");
              return;
          }
          if (!globalEncodedSavestream) {
              globalEncodedSavestream = await encode(globalSavestates);
          }

          const trimmed_stream = await trim(globalEncodedSavestream, 1, 2);
          assert(trimmed_stream instanceof Uint8Array, "Trimmed stream is Uint8Array");
          assert(trimmed_stream.length > 0, "Trimmed stream is not empty");
          
          const trimmed_stream_2 = await trim(globalEncodedSavestream, 1);
          assert(trimmed_stream_2 instanceof Uint8Array, "Trimmed stream (1) is Uint8Array");
        },

        "encode (Compression Efficiency)": async () => {
          const { encode } = globalAPIs;
          assert(globalSavestates.length > 0, "Must have at least 1 savestate");
          
          // Ensure we have an encoded stream
          if (!globalEncodedSavestream) {
            globalEncodedSavestream = await encode(globalSavestates);
          }

          // Calculate total original size
          let totalOriginalSize = 0;
          for (const state of globalSavestates) {
            totalOriginalSize += state.length;
          }

          const compressedSize = globalEncodedSavestream.length;
          const ratio = compressedSize / totalOriginalSize;

          log(`   Original Size:   ${(totalOriginalSize / 1024 / 1024).toFixed(2)} MB`);
          log(`   Compressed Size: ${(compressedSize / 1024 / 1024).toFixed(2)} MB`);
          log(`   Compression Ratio: ${ratio.toFixed(4)}`);

          // Expecting at least 50% reduction (ratio < 0.5)
          assert(ratio < 0.5, `Compression ratio ${ratio.toFixed(4)} is higher than expected (< 0.5)`);
        },
      };

      // ===== FUNCTION PAIR TESTS =====
      pairTests = {
        "splitV86Savestate + recombineV86Savestate (Roundtrip)": async () => {
          const { splitV86Savestate, recombineV86Savestate } = globalAPIs;
          assert(globalSavestates.length > 0, "Must have at least 1 savestate");
          
          for (let i = 0; i < globalSavestates.length; i++) {
              const file_content = globalSavestates[i];
              const { headerBlock, infoBlock, bufferBlock } = splitV86Savestate(file_content);
              const recombined = recombineV86Savestate(headerBlock, infoBlock, bufferBlock);
              assertArraysEqual(recombined, file_content, `Roundtrip ${i}: split + recombine matches original`);
          }
        },
        
        "makeAlignedBufferBlock + makeUnalignedBufferBlock (Roundtrip)": async () => {
          const { splitV86Savestate, makeAlignedBufferBlock, makeUnalignedBufferBlock, textDecoder } = globalAPIs;
          const blockSize = 256;
          const superBlockSize = blockSize * 256;

          for (let i = 0; i < globalSavestates.length; i++) {
              const file_content = globalSavestates[i];
              const { headerBlock, infoBlock, bufferBlock } = splitV86Savestate(file_content);
              const infoJson = JSON.parse(textDecoder.decode(infoBlock));

              const aligned_buffer = makeAlignedBufferBlock(infoJson, bufferBlock, blockSize, superBlockSize);
              const unaligned_buffer = makeUnalignedBufferBlock(infoJson, aligned_buffer, blockSize);
              
              assertArraysEqual(unaligned_buffer, bufferBlock, `Roundtrip ${i}: align + unalign matches original`);
          }
        },

        "encode + decode (Empty Input)": async () => {
          const { encode, decode, decodeLen } = globalAPIs;
          
          // 1. Encode empty array
          const emptyStream = await encode([]);
          assert(emptyStream instanceof Uint8Array, "Empty input produces Uint8Array");
          
          // 2. Check length
          const len = await decodeLen(emptyStream);
          assertEquals(len, 0, "decodeLen returns 0 for empty stream");
          
          // 3. Decode and verify empty
          const decoded = [];
          for await (const state of await decode(emptyStream)) {
              decoded.push(state);
          }
          assertEquals(decoded.length, 0, "Decodes to empty array");
        },

        "encode + decode (Roundtrip)": async () => {
          const { encode, decode } = globalAPIs;
          if (!globalEncodedSavestream) {
            globalEncodedSavestream = await encode(globalSavestates, {
              onProgress: (current, total) => {
                log(`   Encoding progress: ${current}/${total} states`);
              }
            });
          }
          
          const decoded_savestates = [];
          for await (const state of await decode(globalEncodedSavestream)) {
              decoded_savestates.push(state);
          }
          
          assertEquals(decoded_savestates.length, globalSavestates.length, "Decoded savestates length matches original");
          
          for(let i = 0; i < globalSavestates.length; i++) {
              assertArraysEqual(decoded_savestates[i], globalSavestates[i], `Roundtrip ${i}: encode + decode matches original`);
          }
        },

        "encodeStream + decodeStream (Roundtrip)": async () => {
          const { encodeStreaming, decodeStreaming } = globalAPIs;


          async function* stateStreamGenerator() {
            for (const state of globalSavestates) {
              await new Promise(r => setTimeout(r, 100)); // Delay for animation
              yield state;
            }
          }

          let index = 0;
          for await (const state of decodeStreaming(encodeStreaming(stateStreamGenerator()))) {
            assertArraysEqual(state, globalSavestates[index], `Roundtrip ${index}: encodeStreaming + decodeStreaming matches original`);
            index++;
          }
        },

        "encode + decodeOne (Roundtrip)": async () => {
          const { encode, decodeOne } = globalAPIs;
          if (!globalEncodedSavestream) {
            globalEncodedSavestream = await encode(globalSavestates);
          }
          
          for (let i = 0; i < globalSavestates.length; i++) {
              const decoded_one = await decodeOne(globalEncodedSavestream, i);
              assertArraysEqual(decoded_one, globalSavestates[i], `Roundtrip ${i}: encode + decodeOne matches original`);
          }
        },

        "encode + trim + decode (Roundtrip)": async () => {
          const { encode, decode, trim } = globalAPIs;
          if (globalSavestates.length < 3) {
              log("--- Skipping trim roundtrip test: requires at least 3 savestates.");
              return;
          }
          if (!globalEncodedSavestream) {
              globalEncodedSavestream = await encode(globalSavestates);
          }

          const trimmed_stream = await trim(globalEncodedSavestream, 1, 2);
          const decoded = [];
          for await (const state of await decode(trimmed_stream)) {
              decoded.push(state);
          }
          
          assertEquals(decoded.length, 1, "Trim (1, 2) results in 1 state");
          assertArraysEqual(decoded[0], globalSavestates[1], "Roundtrip: encode + trim(1,2) + decode matches state 1");
          
          const trimmed_stream_2 = await trim(globalEncodedSavestream, 1);
          const decoded_2 = [];
          for await (const state of await decode(trimmed_stream_2)) {
              decoded_2.push(state);
          }
          assertEquals(decoded_2.length, globalSavestates.length - 1, "Trim (1) results in correct number of states");
          assertArraysEqual(decoded_2[0], globalSavestates[1], "Roundtrip: encode + trim(1) + decode matches state 1");
          assertArraysEqual(decoded_2[1], globalSavestates[2], "Roundtrip: encode + trim(1) + decode matches state 2");
        },

        "encode + decodeLen (Integration)": async () => {
          const { encode, decodeLen } = globalAPIs;
          if (!globalEncodedSavestream) {
            globalEncodedSavestream = await encode(globalSavestates);
          }
          
          const length = await decodeLen(globalEncodedSavestream);
          assertEquals(length, globalSavestates.length, "encode + decodeLen: length matches original count");
        }
      };
    }

    // Main function to run selected tests
    async function runSelectedTests(testNames) {
      if (testNames.length === 0) {
        log("No tests selected. Please select at least one test.");
        return;
      }

      out.textContent = `Running ${testNames.length} test(s)...\n`;

      for (const testName of testNames) {
        if (individualTests[testName]) {
          await runTest(testName, individualTests[testName]);
        } else if (pairTests[testName]) {
          await runTest(testName, pairTests[testName]);
        } else {
          log(`âš ï¸  WARNING: Test "${testName}" not found in registry.`);
        }
      }

      log("\n--- Selected tests complete ---");
    }

    // --- UI Setup ---
    function setupTestControls() {
      const testControls = document.getElementById("testControls");
      const individualCheckboxes = document.getElementById("individualTestCheckboxes");
      const pairCheckboxes = document.getElementById("pairTestCheckboxes");
      const selectAllCheckbox = document.getElementById("selectAll");
      const selectAllIndividualCheckbox = document.getElementById("selectAllIndividual");
      const selectAllPairsCheckbox = document.getElementById("selectAllPairs");
      const runButton = document.getElementById("runSelectedTests");
      const clearButton = document.getElementById("clearOutput");

      // Create checkboxes for individual tests
      const individualTestNames = Object.keys(individualTests);
      individualCheckboxes.innerHTML = "";
      
      individualTestNames.forEach(testName => {
        const div = document.createElement("div");
        div.className = "test-checkbox-item";
        
        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.id = `test-${testName}`;
        checkbox.value = testName;
        checkbox.checked = true;
        checkbox.dataset.category = "individual";
        
        const label = document.createElement("label");
        label.htmlFor = `test-${testName}`;
        label.textContent = testName;
        
        div.appendChild(checkbox);
        div.appendChild(label);
        individualCheckboxes.appendChild(div);
      });

      // Create checkboxes for pair tests
      const pairTestNames = Object.keys(pairTests);
      pairCheckboxes.innerHTML = "";
      
      pairTestNames.forEach(testName => {
        const div = document.createElement("div");
        div.className = "test-checkbox-item";
        
        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.id = `test-${testName}`;
        checkbox.value = testName;
        checkbox.checked = true;
        checkbox.dataset.category = "pair";
        
        const label = document.createElement("label");
        label.htmlFor = `test-${testName}`;
        label.textContent = testName;
        
        div.appendChild(checkbox);
        div.appendChild(label);
        pairCheckboxes.appendChild(div);
      });

      // Handle "Select All Individual" checkbox
      selectAllIndividualCheckbox.addEventListener("change", () => {
        const checkboxes = individualCheckboxes.querySelectorAll('input[type="checkbox"]');
        checkboxes.forEach(cb => {
          cb.checked = selectAllIndividualCheckbox.checked;
        });
        updateSelectAllState();
      });

      // Handle "Select All Pairs" checkbox
      selectAllPairsCheckbox.addEventListener("change", () => {
        const checkboxes = pairCheckboxes.querySelectorAll('input[type="checkbox"]');
        checkboxes.forEach(cb => {
          cb.checked = selectAllPairsCheckbox.checked;
        });
        updateSelectAllState();
      });

      // Handle "Select All" checkbox
      selectAllCheckbox.addEventListener("change", () => {
        const allCheckboxes = document.querySelectorAll('#individualTestCheckboxes input[type="checkbox"], #pairTestCheckboxes input[type="checkbox"]');
        allCheckboxes.forEach(cb => {
          cb.checked = selectAllCheckbox.checked;
        });
        selectAllIndividualCheckbox.checked = selectAllCheckbox.checked;
        selectAllPairsCheckbox.checked = selectAllCheckbox.checked;
      });

      // Handle individual checkbox changes
      function updateSelectAllState() {
        const individualCheckboxes = document.querySelectorAll('#individualTestCheckboxes input[type="checkbox"]');
        const pairCheckboxes = document.querySelectorAll('#pairTestCheckboxes input[type="checkbox"]');
        const allIndividualChecked = Array.from(individualCheckboxes).every(cb => cb.checked);
        const allPairsChecked = Array.from(pairCheckboxes).every(cb => cb.checked);
        
        selectAllIndividualCheckbox.checked = allIndividualChecked;
        selectAllPairsCheckbox.checked = allPairsChecked;
        selectAllCheckbox.checked = allIndividualChecked && allPairsChecked;
      }

      individualCheckboxes.addEventListener("change", updateSelectAllState);
      pairCheckboxes.addEventListener("change", updateSelectAllState);

      // Handle "Run Selected Tests" button
      runButton.addEventListener("click", async () => {
        const selectedTests = Array.from(document.querySelectorAll('#individualTestCheckboxes input[type="checkbox"]:checked, #pairTestCheckboxes input[type="checkbox"]:checked'))
          .map(cb => cb.value)
          .filter(v => v);
        
        try {
          await runSelectedTests(selectedTests);
        } catch(err) {
          fail("A critical error occurred during test execution.", err);
        }
      });

      // Handle "Clear Output" button
      clearButton.addEventListener("click", () => {
        out.textContent = "";
      });

      // Show the test controls
      testControls.style.display = "block";
    }

    // --- Main Entry Point ---
    document.getElementById("folderPicker").addEventListener("change", async e => {
      out.textContent = "Loading files...";
      const savestates = [];
      
      const files = Array.from(e.target.files)
        .filter(f => f.name.toLowerCase().endsWith(".bin"))
        .sort((a, b) => a.name.localeCompare(b.name, undefined, { numeric: true }));

      if (!files.length) {
        out.textContent = "No .bin files found in selected folder. Please try again.";
        return;
      }
      
      log(`Loading ${files.length} savestate(s)...`);

      for (const file of files) {
        const buf = new Uint8Array(await file.arrayBuffer());
        savestates.push(buf);
      }
      
      // Initialize tests with loaded savestates
      initializeTests(savestates);
      
      // Setup and show test controls
      setupTestControls();
      
      // Update file selection display
      const selectedFilesDiv = document.getElementById("selectedFiles");
      selectedFilesDiv.textContent = `Selected: ${files.length} .bin file(s)`;
      selectedFilesDiv.style.display = "block";
      
      log("Files loaded. Select tests and click 'Run Selected Tests' to begin.");
    });

    // Check for dependencies on load
    window.addEventListener("DOMContentLoaded", () => {
         if (typeof MessagePack === 'undefined') fail("FATAL: 'MessagePack' is not defined.");
         if (typeof jsonpatch === 'undefined') fail("FATAL: 'jsonpatch' is not defined.");
    });

  </script>

</body>
</html>
