<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Clickie Album Capturer</title>

    <link rel="stylesheet" href="album-style.css">

    <script src="libv86.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/@msgpack/msgpack@3.1.1/dist.umd/msgpack.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/fast-json-patch@3.1.1/dist/fast-json-patch.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>

    <script src="../savestreams_updated.js"></script>

    <script src="album_capturer.js"></script>
</head>

<body>

    <script>
        "use strict";

        window.onload = function () {
            // --- 0.1 Storage Quota Check ---
            async function checkStorageQuota() {
                if (navigator.storage && navigator.storage.estimate) {
                    try {
                        const { quota } = await navigator.storage.estimate();
                        const quotaMB = (quota / 1024 / 1024).toFixed(0);
                        const quotaGB = (quota / 1024 / 1024 / 1024).toFixed(2);

                        console.log(`Storage Quota: ${quotaMB} MB`);

                        // Threshold: Warn if less than 2GB (Incognito usually has ~100MB - 300MB)
                        if (quota < 2 * 1024 * 1024 * 1024) {
                            const warningBox = document.createElement('div');
                            warningBox.style.backgroundColor = '#ffdddd';
                            warningBox.style.borderLeft = '6px solid #f44336';
                            warningBox.style.padding = '15px';
                            warningBox.style.marginBottom = '20px';
                            warningBox.innerHTML = `
                                <strong>‚ö†Ô∏è Low Storage Quota Detected (${quotaMB} MiB)</strong><br>
                                Your browser is limiting storage space. This usually happens in 
                                <strong>Incognito / Private Mode</strong> or if your disk is full.<br>
                                <br>
                                Recording requires ~2GiB. Please switch to a normal window or clear disk space to avoid crashes.
                            `;
                            
                            // Insert warning at the top of the controls
                            const controls = document.getElementById('controls');
                            controls.parentNode.insertBefore(warningBox, controls);
                            
                            // Optional: Disable the record button to prevent the crash
                            document.getElementById('record').disabled = true;
                            document.getElementById('status').textContent = "Error: Insufficient storage quota.";
                            document.getElementById('status').style.color = "red";
                        }
                    } catch (err) {
                        console.warn("Could not check storage quota:", err);
                    }
                }
            }

            checkStorageQuota();

            // --- 1. UI References (Moved to top) ---
            const statusLabel = document.getElementById("status");
            const screenContainer = document.getElementById("screen_container");
            const machineSelect = document.getElementById("machineSelect");
            const saveButton = document.getElementById("save");
            const recordButton = document.getElementById("record");
            const scaleInput = document.getElementById("scaleInput");
            const playerWrapper = document.getElementById("player-wrapper");
            const browserWarning = document.getElementById("browser-warning");

            let emulator = null;
            let capturer = null;

            // Utility: preload and decompress the gz file
            async function prepareGzFile(url) {
                console.log("[prepareGzFile] Fetching:", url);

                try {
                    const resp = await fetch(url);
                    console.log("[prepareGzFile] fetch status:", resp.status);

                    if (!resp.ok) throw new Error("Failed to fetch: " + resp.status);

                    const gz = new Uint8Array(await resp.arrayBuffer());
                    console.log("[prepareGzFile] gzipped bytes:", gz.length);

                    const decompressed = pako.ungzip(gz);
                    console.log("[prepareGzFile] decompressed bytes:", decompressed.length);

                    return decompressed.buffer;
                } catch (err) {
                    console.error("[prepareGzFile] ERROR:", err);
                    return null;
                }
            }

            // --- 0. Check Dependencies ---
            if (typeof V86 === 'undefined' || typeof AlbumCapturer === 'undefined') {
                statusLabel.textContent = "Error: Libraries not loaded.";
                statusLabel.style.color = "red";
                return;
            }

            // --- 2. Define Configurations ---
            const common_specs = {
                wasm_path: "../assets/v86.wasm",
                screen_container: screenContainer,
                bios: { url: "../assets/seabios.bin.file" },
                vga_bios: { url: "../assets/vgabios.bin.file" },
                autostart: true,
            };

            const configurations = {
                dsl: {
                    ...common_specs,
                    memory_size: 32 * 1024 * 1024,
                    vga_memory_size: 2 * 1024 * 1024,
                    cdrom: { url: "../assets/dsl-4.11.rc2.iso.file" },
                    initial_state: { url: "../assets/v86state-dsl.bin.file" },
                },
                msdos: {
                    ...common_specs,
                    memory_size: 64 * 1024 * 1024,
                    vga_memory_size: 8 * 1024 * 1024,
                    hda: { url: "../assets/doom-hd.img.gz" },
                    initial_state: { url: "../assets/doom-attract-state.bin.gz" },
                },
                android: {
                    ...common_specs,
                    memory_size: 256 * 1024 * 1024,
                    vga_memory_size: 8 * 1024 * 1024,
                    cdrom: { url: "../assets/android-x86-1.6-r2.iso" },
                    initial_state: { url: "../assets/android-initial-state.bin.gz" },
                }
            };

            // --- 3. Load Machine Logic ---
            async function loadMachine(configKey) {
                saveButton.disabled = true;
                recordButton.disabled = true;
                machineSelect.disabled = true;

                if (emulator) {
                    emulator.stop();
                    emulator.destroy();
                    emulator = null;
                }

                const specs = { ...configurations[configKey] };
                let runtimeSpecs = {...specs};
                statusLabel.textContent = `Initializing ${configKey}...`;
                statusLabel.style.color = "#333";

                try {
                    if (configKey === "msdos") {
                        console.log("[loadMachine] Preloading MS-DOS HDA and initial state...");
                        const hdaBuffer = await prepareGzFile( specs.hda.url );
                        const initialStateBuffer = await prepareGzFile( specs.initial_state.url );
                        if (!hdaBuffer || !initialStateBuffer) throw new Error("HDA buffer or initial state buffer is null");

                        runtimeSpecs.hda = { buffer: hdaBuffer };
                        runtimeSpecs.initial_state = { buffer: initialStateBuffer };
                        console.log("[loadMachine] HDA buffer ready:", runtimeSpecs.hda);
                        console.log("[loadMachine] Initial state buffer ready:", runtimeSpecs.initial_state);
                    }

                    if (configKey === "android") {
                        console.log("[loadMachine] Preloading Android x86 initial state...");
                        const buffer = await prepareGzFile( specs.initial_state.url );
                        if (!buffer) throw new Error("Initial state buffer is null");

                        runtimeSpecs.initial_state = { buffer };
                        console.log("[loadMachine] Initial state buffer ready:", runtimeSpecs.initial_state);

                    }

                    console.log("[loadMachine] Runtime specs passed to V86:", runtimeSpecs);

                    // Initialize Emulator and Capturer
                    emulator = window.emulator = new V86(runtimeSpecs);
                    capturer = new AlbumCapturer(emulator, specs);

                    // Set up quota exceeded callback
                    capturer.onQuotaExceeded = async () => {
                        statusLabel.textContent = "‚ö†Ô∏è Storage quota exceeded! Stopping recording and saving...";
                        statusLabel.style.color = "#e67e22";
                        recordButton.disabled = true;
                        recordButton.classList.remove("recording");
                        recordButton.value = "‚è≥ Finalizing clickie (quota exceeded)...";

                        const onProgress = (current, total) => {
                            const percent = Math.round((current / total) * 100);
                            statusLabel.textContent = `‚ö†Ô∏è Quota exceeded! Compressing state ${current} of ${total} (${percent}%)`;
                            statusLabel.style.color = "#e67e22";
                        };

                        // Wait for stopRecording to complete
                        const encodingStartTime = Date.now();
                        const success = await capturer.stopRecording(onProgress);
                        const encodingElapsedMs = Date.now() - encodingStartTime;

                        recordButton.disabled = false;

                        if (success) {
                            // Format encoding time
                            const encodingSeconds = (encodingElapsedMs / 1000).toFixed(1);
                            const encodingMinutes = Math.floor(encodingElapsedMs / 60000);
                            const remainingSeconds = ((encodingElapsedMs % 60000) / 1000).toFixed(1);
                            
                            let encodingTimeText;
                            if (encodingMinutes > 0) {
                                encodingTimeText = `${encodingMinutes}m ${remainingSeconds}s`;
                            } else {
                                encodingTimeText = `${encodingSeconds}s`;
                            }
                            
                            recordButton.value = "üî¥ Start Recording Another Clickie";
                            statusLabel.textContent = `‚ö†Ô∏è Clickie saved (stopped early due to quota). Ready for next. (Encoding took ${encodingTimeText})`;
                            statusLabel.style.color = "#e67e22";
                            console.log("Recording stopped due to quota and clickie finalized.");
                        } else {
                            recordButton.value = "üî¥ Start Recording Clickie";
                            statusLabel.textContent = "‚ùå Save failed after quota exceeded. See console for details.";
                            statusLabel.style.color = "red";
                            console.log("Recording stopped due to quota but failed to save clickie.");
                        }
                    };

                    emulator.add_listener("emulator-error", (err) => {
                        console.error("[V86] Emulator error:", err);
                        statusLabel.textContent = "Error: " + (err.message || "Check console");
                        statusLabel.style.color = "red";
                        machineSelect.disabled = false;
                    });

                    emulator.add_listener("emulator-loaded", async () => {
                        console.log("[V86] Emulator loaded successfully");
                        const canvas = document.getElementById("emulator-canvas");
                        await capturer.init(canvas);
                        scaleInput.dispatchEvent(new Event("input"));

                        statusLabel.textContent = `Ready: ${configKey}. Select album to record.`;
                        statusLabel.style.color = "#28a745";
                        saveButton.disabled = false;

                        if (!capturer.albumDirHandle) {
                            machineSelect.disabled = false;
                        }
                    });

                } catch (e) {
                    console.error("[loadMachine] Initialization failed:", e);
                    statusLabel.textContent = `Init Failed: ${e.message}`;
                    statusLabel.style.color = "red";
                    machineSelect.disabled = false;
                }
            }

            // --- 4. Event Listeners ---

            // Machine Switcher
            machineSelect.addEventListener("change", (e) => {
                machineSelect.blur();
                loadMachine(e.target.value);
            });

            // Mouse Lock
            screenContainer.addEventListener("click", () => {
                if (emulator) {
                    scaleInput.blur();
                    emulator.lock_mouse();
                }
            });

            // Scale Logic
            scaleInput.addEventListener("input", () => {
                // Clamp value between 50 and 100
                let val = parseInt(scaleInput.value);
                if (val < 50) val = 50;
                if (val > 100) val = 100;

                playerWrapper.style.width = val + "%";
            });

            // Album Logic (Lockdown on Success)
            saveButton.addEventListener("click", async () => {
                saveButton.blur();
                statusLabel.textContent = "Select a folder...";

                const success = await capturer.createAlbum();

                if (success) {
                    // --- Manifest Check ---
                    try {
                        const handle = await capturer.albumDirHandle.getFileHandle("manifest.json");
                        const file = await handle.getFile();
                        const manifest = JSON.parse(await file.text());

                        const currentSpec = { ...capturer.v86_specs };
                        delete currentSpec.screen_container;
                        const manifestSpec = { ...manifest.machine_spec };
                        delete manifestSpec.screen_container;

                        if (JSON.stringify(currentSpec) !== JSON.stringify(manifestSpec)) {
                            alert("‚ö†Ô∏è Spec Mismatch! Switch machine or pick another folder.");
                            capturer.albumDirHandle = null;
                            statusLabel.textContent = "Cancelled (Spec mismatch).";
                            statusLabel.style.color = "red";
                            return;
                        }
                    } catch (e) { console.warn("Manifest check skipped:", e); }

                    // --- C. FINAL LOCKDOWN ---
                    // Disable selector PERMANENTLY for this session
                    machineSelect.disabled = true;
                    saveButton.disabled = true;

                    saveButton.value = "üìÇ Album Open";
                    recordButton.disabled = false;
                    statusLabel.textContent = "Ready to record.";
                    statusLabel.style.color = "#28a745";
                } else {
                    statusLabel.textContent = "Album selection cancelled.";
                }
            });

            // Recording Logic
            recordButton.addEventListener("click", async () => {
                recordButton.blur();
                if (capturer.isRecording) {
                    recordButton.disabled = true;
                    recordButton.classList.remove("recording");
                    recordButton.value = "‚è≥ Finalizing clickie (may take >1 min)...";
                    statusLabel.textContent = "Encoding video & compressing states. Please wait...";

                    const onProgress = (current, total) => {
                        const percent = Math.round((current / total) * 100);
                        statusLabel.textContent = `Compressing state ${current} of ${total} (${percent}%)`;
                        statusLabel.style.color = "#e67e22"; // Orange color
                    };

                    const encodingStartTime = Date.now();
                    const success = await capturer.stopRecording(onProgress);
                    const encodingElapsedMs = Date.now() - encodingStartTime;

                    recordButton.disabled = false;

                    if (success) {
                        // Format encoding time
                        const encodingSeconds = (encodingElapsedMs / 1000).toFixed(1);
                        const encodingMinutes = Math.floor(encodingElapsedMs / 60000);
                        const remainingSeconds = ((encodingElapsedMs % 60000) / 1000).toFixed(1);
                        
                        let encodingTimeText;
                        if (encodingMinutes > 0) {
                            encodingTimeText = `${encodingMinutes}m ${remainingSeconds}s`;
                        } else {
                            encodingTimeText = `${encodingSeconds}s`;
                        }
                        
                        recordButton.value = "üî¥ Start Recording Another Clickie";
                        statusLabel.textContent = `Clickie saved! Ready for next. (Encoding took ${encodingTimeText})`;
                        statusLabel.style.color = "#28a745";
                        console.log("Recording stopped and clickie finalized.");
                    } else {
                        recordButton.value = "üî¥ Start Recording Clickie";
                        statusLabel.textContent = "Save failed. See console for details.";
                        statusLabel.style.color = "red";
                        console.log("Recording stopped but failed to save clickie.");
                    }

                } else {
                    statusLabel.textContent = "Recording... (Mouse locked)";
                    statusLabel.style.color = "#dc3545";
                    emulator.lock_mouse();

                    capturer.onQuotaExceeded = () => {
                        console.warn("Storage quota exceeded limit. Stopping recording.");
                        alert("Recording stopped automatically to prevent data loss (Disk Full).");
                        // Trigger the stop logic as if the user clicked it
                        recordButton.click();
                    };

                    await capturer.startRecording();
                    recordButton.value = "‚èπ Stop Recording";
                    recordButton.classList.add("recording");
                }
            });


        };
    </script>

    <div id="browser-warning">
        <strong>‚ö†Ô∏è Browser Compatibility Warning:</strong> This application requires the
        <code>window.showDirectoryPicker</code> API (File System Access), which is not supported in your current
        browser.
        <br>
        Please use a desktop version of <strong>Chrome, Edge, or Opera</strong>.
        <br>
        <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/showDirectoryPicker" target="_blank">Learn more
            at MDN</a>.
    </div>

    <h1>Clickie Album Capturer</h1>

    <div id="instructions">
        <h3>Instructions & Tips</h3>
        <ul>
            <li><strong>Step 1:</strong> Select your Machine Type (DSL, MS-DOS, Android). <em>You cannot change this
                    after opening an album.</em></li>
            <li><strong>Step 2:</strong> Wait for the emulator to initialize (Wait for Status: <span
                    style="color: #28a745;">Ready</span>).</li>
            <li><strong>Step 3:</strong> Click <em>"Create/Open Album Folder"</em>. This <strong>locks</strong> your
                machine selection for the session.</li>
            <li><strong>Step 4:</strong> Click <em>"Start Recording Clickie"</em> to begin capturing video, inputs, and
                states. The mouse will be automatically locked to the emulator.</li>
            <li><strong>Step 5:</strong> Interact! (<strong>ESC</strong> to unlock mouse if needed). Click
                <em>"Stop"</em> when done. This will finalize and save the clickie to your album folder. </li> 
            <li><strong>‚ö†Ô∏è Note:</strong> Finalizing a clickie involves heavy compression and may take over a minute.</li>
        </ul>
    </div>

    <div id="player-wrapper">
        <div id="screen_container" class="capturer-visible">
            <div style="white-space: pre; font: 14px monospace; line-height: 14px"></div>
            <canvas id="emulator-canvas"></canvas>
        </div>
    </div>

    <div id="controls">
        <select id="machineSelect">
            <option disabled selected>Choose machine</option>
            <option value="dsl">DSL Linux</option>
            <option value="msdos">MS-DOS</option>
            <option value="android">Android x86</option>
        </select>
        <input id="save" type="button" value="üìÇ Create/Open Album Folder" disabled />
        <input id="record" type="button" value="üî¥ Start Recording Clickie" disabled />

        <div style="flex-grow: 1;"></div> <label
            style="font-weight: bold; color: #555; margin-left: 10px;">Scale:</label>
        <input id="scaleInput" type="number" value="80" min="50" max="100"
            style="width: 50px; padding: 5px; border-radius: 5px; border: 1px solid #ccc;" />
        <span style="color: #555;">%</span>

        <span id="status">Waiting for emulator...</span>
    </div>

    <script>
        // Check for File System Access API support
        if (!('showDirectoryPicker' in window)) {
            document.getElementById('browser-warning').style.display = 'block';
        }
    </script>

</body>

</html>